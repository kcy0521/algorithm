n = int(input())

arr = list(int(input()) for _ in range(n))
dp = [0] * (n)
# 1. 계단은 +1 or +2 뿐이다. 
# 2. 연속된 3개의 계단을 밟으면 안된다. 
# 3. 마지막 도착 계단은 반드시 밟아야 한다. 
# 총점수의 최댓값을 구해라. dp에 대한 개념을 확실히 이해 해야한다. dp에 대한개념 

if len(arr) <=2:
    print(sum(arr))
else: # 계단이 3개 이상일 경우
    dp[0] = arr[0] # 첫번째 계단 수동 계산
    dp[1] = arr[0] + arr[1] # 둘째 계단까지 수동 계산
    for i in range(2,n):
        
        dp[i] = max(dp[i-3] + arr[i-1] + arr[i], dp[i-2] + arr[i]) # 이게 핵심코드
    print(dp[-1])

'''
이 문제의 경우 botton up 방식이다. ?? 이방식 맞어? 
첫번째 두번째 수를 수동으로 계산한점을 보면 알 수 있다. 
for문을 살펴봐보자.
1. 마지막 계단의 전계단을 밟은 경우
2. 마지막 계단의 전 계단을 밟지 않은 경우 
이해가 안되는 부분 
dp[i] = max(dp[i-3] + arr[i-1] + arr[i], dp[i-2] + arr[i]) # 이게 핵심코드
여기서 dp[i-3] + arr[i-1] + arr[i] 이부분이 이해가 안되서 넘어갈 수가 없다. 
마지막 계단 + 그 전계단 + 전전 계단 
i = 2 일경우 dp[-1] 이 되게 되는데 n=3 일때 dp[2]의 값을 넣기 전이기 때문에 
dp[-1] = 0 이 될 수 밖에 없다. 그래서 이부분이 문제없이 지나가게 된다. 
i = 2 일때의 반복문이 끝나야 dp[2] != 0 이 되기 때문에 문제없이 계속 진행이 가능하다. 
이부분 이해하는게 너무 어렵다. 시바
'''
